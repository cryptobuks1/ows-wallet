'use strict';

/**
 * Builds the plugin catalog from an app-template 'app.config.json' plugins entry.
 * Installs the plugins into the app www/ directory.
 */

var fs = require('fs-extra');
var path = require('path');
var utils = require(path.resolve(__dirname, './utils'));
var execSync = require('child_process').execSync;
var appConfig;

// Relative to the project root directory.
var APP_PATH = './app/';
var WWW_PATH = './www/';
var TMP_PATH = './build/';
var PLUGIN_ROOT = 'plugins/';

var KNOWN_PLUGIN_KINDS = ['applet', 'servlet'];

// Build app/app.plugins.js.
// Publish plugin skins to the app theme directory.
// 
var buildPluginCatalog = function(config, mode) {
  var catalog = {
    plugins: {}
  };

  appConfig = config;

  var content = '';
  content += '\'use strict\';\n\n';
  content += '// Do not edit, this file is auto-generated by grunt.\n\n';
  content += 'angular.module(\'owsWalletApp\').constant(\'pluginCatalog\', \n';

  // Get a list of files for all kinds of plugins combined.
  var pluginList = Object.keys(appConfig.plugins);
  var pluginIds = [];

  console.log('Installing plugins...');

  for (var i = 0; i < pluginList.length; i++) {
    var pluginNpmPath = pluginList[i]; // Path to plugin npm package
    processPlugin(pluginNpmPath);
  }

  content += utils.cleanJSONQuotesOnKeys(JSON.stringify(catalog, null, 2));
  content += ');\n';
  fs.writeFileSync(APP_PATH + 'app.plugincatalog.js', content);
  return;

  // Called recursively to process all plugin dependencies.
  function processPlugin(pluginNpmPath) {

    // Locate the plugin.
    var pluginReleaseDir; // Directory containing the plugin installable release
    var pluginWwwDir; // Runtime plugin directory relative to www/
    var pluginInstallDir; // Plugin installation directory relative to project root
    var pluginApisDir; // Temporary build scratch directory for accumulating plugin api's

    // NPM plugins
    pluginReleaseDir = 'node_modules/' + pluginNpmPath + '/release/';

    // Read plugin configuration.
    var pluginConfig = utils.readJSON(pluginReleaseDir + 'plugin.json');

    // Set local/app paths for installation of plugin.
    // Plugins install in a version id subdirectory. Allows multiple version of the same
    // plugin to be installed.
    pluginWwwDir = PLUGIN_ROOT + pluginNpmPath + '/' + pluginConfig.header.version + '/';
    pluginInstallDir = WWW_PATH + pluginWwwDir;
    pluginApisDir = TMP_PATH + 'plugin-apis/' + pluginNpmPath + '/' + pluginConfig.header.version + '/';

    fs.ensureDirSync(pluginInstallDir);
    fs.ensureDirSync(pluginApisDir);

    pluginConfig.uri = pluginWwwDir;

    // Replace tags.
    var pluginJSON = JSON.stringify(pluginConfig);
    pluginJSON = pluginJSON.replace(/<plugin-path>/g, pluginConfig.uri.slice(0, -1));
    pluginConfig = JSON.parse(pluginJSON);

    for (var n = 0; n < pluginConfig.resources.length; n++) {
      var re = new RegExp('<resource-' + n + '>', 'g');
      pluginJSON = pluginJSON.replace(re, pluginConfig.resources[n]);
    }
    // End replace tags.

    pluginConfig = JSON.parse(pluginJSON);

    // Detect and fail if duplicate plugin id exists.
    if (pluginIds.indexOf(pluginConfig.header.id) >= 0) {
      throw new Error('ERROR - Duplicate plugin id detected: \'' + pluginConfig.header.id + '\'');
    }

    var allowInstall = KNOWN_PLUGIN_KINDS.includes(pluginConfig.header.kind);

    if (!allowInstall) {
      throw new Error('ERROR - unknown plugin kind [' + pluginConfig.header.kind + ']');
    }

    // Install the plugin; fail script if unable to install.
    try {
      fs.copySync(pluginReleaseDir + 'www', pluginInstallDir);
      fs.copySync(pluginReleaseDir + 'api', pluginApisDir); // Grunt references this location.

      // Don't push plugin skin configuration files to app.
      utils.removeFilesByTypeRecursive(pluginInstallDir + 'skins', 'json');

    } catch (ex) {
       throw new Error('Failed to install plugin \'' + pluginNpmPath + '\': ' + ex);
    }

    // All plugins inserted into the app catalog storage during the build process have 'build' as the 'source'.
    // Plugins inserted from a download should include a URL as the value of 'source'.
    pluginConfig.source = 'build';

    switch (pluginConfig.header.kind) {
      case 'applet':
        // Check the main view path.
        if (pluginConfig.mainView && pluginConfig.mainView.indexOf('/') >= 0) {
          throw new Error('Applet in \'' + filelist[i] + '\' should not include a path in \'mainView\'. Use only the view name; e.g., \'index.html\'.');
        }

        // Set the default skin id for the plugin.
        var skinsMessage = 'No skins';
        if (pluginConfig.skins && Object.keys(pluginConfig.skins).length > 0) {
          skinsMessage = 'Skins for this plugin:';

          var s = Object.keys(pluginConfig.skins);

          for (var j=0; j < s.length; j++) {
            // Set the default skin id.
            if (pluginConfig.skins[s[j]].default) {
              pluginConfig.defaultSkinId = s[j];
            }
            skinsMessage += '\n      \'' + s[j] + '\'';
          }
          // If no default skin specified then choose the first one in the list.
          if (!pluginConfig.defaultSkinId) {
            pluginConfig.defaultSkinId = s[0];
          }
        }

        // Process plugin dependencies.
        if (pluginConfig.dependencies) {
          Object.keys(pluginConfig.dependencies).forEach(function(id) {
            // Install the dependant plugin package.
            // Only allowed one package; silently ignore any others.
            var pkgName = Object.keys(pluginConfig.dependencies[id].package)[0];
            var ver = pluginConfig.dependencies[id].package[pkgName].replace('^', '');

            if (mode != 'dev') {
              execSync('npm install ' + pkgName + '@' + ver, { cwd: '.', stdio: [0,1,2] });
            }

            // Recursively process the newly installed plugin.
            processPlugin(pkgName);
          });
        }

        break;

      case 'servlet':
        // Nothing to do.
        break;
    }

    // Add the plugin to the catalog.
    catalog.plugins[pluginConfig.header.id] = pluginConfig;

    // Remember that we installed this plugin.
    pluginIds.push(pluginConfig.header.id);

    var installSummary = '>>  [' + pluginConfig.header.kind + '] \'' + pluginNpmPath + '\'@' + pluginConfig.header.version + ' (' + pluginConfig.header.id + ')' + '\n';
    (skinsMessage ? installSummary += '    ' + skinsMessage + '\n' : null);
    if (pluginConfig.dependencies && Object.keys(pluginConfig.dependencies).length > 0) {
      installSummary += '    Dependencies\n';
      Object.keys(pluginConfig.dependencies).forEach(function(d){
        installSummary += '      ' + d + '\n';
      });

    } else {
      installSummary += '    No dependencies' + '\n';
    }

    console.log(installSummary);
  };
};

module.exports = {
  build: buildPluginCatalog
};
